				;file E:\				;1	//products mode:   MW
				;2	//functional description: 
				;3	//MCU mode:        HT66F018
				;4	//MCU frequency:   8MHz
				;5	//designer:        xj.jiang
				;6	//data:    2018/7/27 10:58
				;7	//record:
				;8	
				;9	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				;10	#include "base.h"
				;11	#define EXTERN
				;12	#define VAR_DEFINE
				;13	#include "Var.h"
				;14	void PowerDownFunc(void);
				;15	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				;16	void main()
				;17	{
				@code .SECTION 'CODE'
				include HT66F018.inc
0000	2821	jmp     begin_startup_value
0001	0201	sub     a, MP0
				startupend3:
				@start .SECTION 'CODE'
005B	286A	jmp     _main
				startup_value:
				@ROMDATA_BASE .SECTION 'CODE'
005C	000C	jmp     L000C
005D	00C0	mov     PC, a
				;18	    InitSys();				//				_main:
				_main:
006A	2363	call    _InitSys
				;19	    InitRam();				//RAM006B	23B2	call    _InitRam
				;20	    while(1)
				;21	    {
				;22	        GCC_CLRWDT();		//				_L7:
006C	0001	clr     wdt
				;23	        Func();				//006D	226A	call    _Func
				;24			if(TaskADCRdyFlag)
006E	78BE	snz     maiFlagB[0].1
006F	2877	jmp     _L3
				;25			{
				;26				TaskADCRdyFlag = false;
0070	74BE	clr     maiFlagB[0].1
				;27		        GetPTCValu();		//PTC0071	2083	call    _GetPTCValu
				;28		        if(NoZeroTime > 50)
0072	0F32	mov     a, 32H
0073	4226	sub     a, NoZeroTime[0]
0074	3C0A	sz      C
0075	2877	jmp     _L3
				;29		        {
				;30		        	ZeroFlag = true;
0076	703F	set     maiFlagA[0].0
				;31		        }
				;32			}
				;33			if(TaskKeyRdy)
				_L3:
0077	7ABD	snz     LEDG[0].5
0078	287C	jmp     _L5
				;34			{
				;35				TaskKeyRdy = false;
0079	76BD	clr     LEDG[0].5
				;36		        GetSwitch();	//007A	24C1	call    _GetSwitch
				;37		        GetKey();		//007B	2460	call    _GetKey
				;38			}
				;39			PowerDownFunc();	//				_L5:
007C	2002	call    _PowerDownFunc
				;40			if(TaskChkLoadRdy)  //007D	7ABE	snz     maiFlagB[0].5
007E	286C	jmp     _L7
				;41			{
				;42				TaskChkLoadRdy = false;
007F	76BE	clr     maiFlagB[0].5
				;43				GetLoadValu();
0080	217F	call    _GetLoadValu
0081	286C	jmp     _L7
0082	2882	jmp     $
				;44			}
				;45	    }
				;46	}
				;file E:\				;1	#include "base.h"
				;2	#define EXTERN extern
				;3	#include "Var.h"
				;4	unsigned char InitEepRom(void)
				;5	{
				;6	/*	unsigned char i,j;
				;7	    _eea = 0x11;
				;8	    _mp1 = 0x40;
				;9	    _bp = 1;
				;10	    asm("set %0.1":"=m"(_iar1));
				;11	    asm("set %0.0":"=m"(_iar1));
				;12	    while(_iar1&0x01) ;
				;13	    _iar1 = 0;
				;14	    _bp = 0;
				;15	    WaterTmpIndex = _eed;
				;16		i = WaterTmpIndex;
				;17		if(WaterTmpIndex > 4)
				;18			return 1;
				;19	
				;20	    _eea = 0x12;
				;21	    _mp1 = 0x40;
				;22	    _bp = 1;
				;23	    asm("set %0.1":"=m"(_iar1));
				;24	    asm("set %0.0":"=m"(_iar1));
				;25	    while(_iar1&0x01) ;
				;26	    _iar1 = 0;
				;27	    _bp = 0;
				;28	    WaterMlIndex = _eed;
				;29	    i ^= WaterMlIndex;
				;30		if(WaterMlIndex > 4)
				;31			return 1;
				;32		
				;33	    _eea = 0x13;
				;34	    _mp1 = 0x40;
				;35	    _bp = 1;
				;36	    asm("set %0.1":"=m"(_iar1));
				;37	    asm("set %0.0":"=m"(_iar1));
				;38	    while(_iar1 & 0x01) ;
				;39	    _iar1 = 0;
				;40	    _bp = 0;
				;41	 	i ^= _eed;	
				;42		if(_eed > 1)
				;43			return 1;
				;44	    if(_eed == 0)  
				;45	    	LEDBGyuan = false;
				;46	    else  
				;47	    	LEDBGyuan = true;
				;48	
				;49	    _eea = 0x14;
				;50	    _mp1 = 0x40;
				;51	    _bp = 1;
				;52	    asm("set %0.1":"=m"(_iar1));
				;53	    asm("set %0.0":"=m"(_iar1));
				;54	    while(_iar1 & 0x01) ;
				;55	    _iar1 = 0;
				;56	    _bp = 0;
				;57	    if(_eed != i)  
				;58	    	return 1;
				;59	    else
				;60	    	return 0;*/
				;61		return 0;    	
				;62	}
				;63	
				;64	void WriteEepRom(void)
				;65	{
				;66	/*	unsigned char i,m,n;
				;67	
				;68	    for(i=0;i<3;i++)
				;69	    {
				;70	        _eea = 0x11;			//				;71	        m = WaterTmpIndex;
				;72	        _eed = m;
				;73	        _mp1 = 0x40;
				;74	        _bp = 1;
				;75	        _emi = 0;
				;76	        asm("set %0.3":"=m"(_iar1));
				;77	        asm("set %0.2":"=m"(_iar1));
				;78	        _emi = 1;
				;79	        while(_iar1 & 0x04) ;
				;80	        _iar1 = 0;
				;81	        _bp = 0;
				;82	
				;83	        _eea = 0x12;		//				;84	        n = WaterMlIndex;
				;85	        m ^= n;
				;86	        _eed = n;
				;87	        _mp1 = 0x40;
				;88	        _bp = 1;
				;89	        _emi = 0;
				;90	        asm("set %0.3":"=m"(_iar1));
				;91	        asm("set %0.2":"=m"(_iar1));
				;92	        _emi = 1;
				;93	        while(_iar1 & 0x04) ;
				;94	        _iar1 = 0;
				;95	        _bp = 0;
				;96	    
				;97	        _eea = 0x13;		//				;98	        n = (u8)LEDBGyuan;
				;99	        m ^= n;
				;100	        _eed = n;
				;101	        _mp1 = 0x40;
				;102	        _bp = 1;
				;103	        _emi = 0;
				;104	        asm("set %0.3":"=m"(_iar1));
				;105	        asm("set %0.2":"=m"(_iar1));
				;106	        _emi = 1;
				;107	        while(_iar1 & 0x04) ;
				;108	        _iar1 = 0;
				;109	        _bp = 0;        
				;110	    
				;111	        _eea=0x14;			//				;112	        _eed=m;
				;113	        _mp1=0x40;
				;114	        _bp=1;
				;115	        _emi=0;
				;116	        asm("set %0.3":"=m"(_iar1));
				;117	        asm("set %0.2":"=m"(_iar1));
				;118	        _emi=1;
				;119	        while(_iar1 & 0x04) ;
				;120	        _iar1=0;
				;121	        _bp=0;
				;122	        */
				;123	/*
				;124	        _eea=0x11;
				;125	        _mp1=0x40;
				;126	        _bp=1;
				;127	        asm("set %0.1":"=m"(_iar1));
				;128	        asm("set %0.0":"=m"(_iar1));
				;129	        while(_iar1 & 0x01) ;
				;130	        _iar1 = 0;
				;131	        _bp = 0;
				;132	        k = _eed;
				;133	        k <<= 8;
				;134	    
				;135	        _eea=0x12;
				;136	        _mp1=0x40;
				;137	        _bp=1;
				;138	        asm("set %0.1":"=m"(_iar1));
				;139	        asm("set %0.0":"=m"(_iar1));
				;140	        while(_iar1&0x01) ;
				;141	        _iar1=0;
				;142	        _bp=0;
				;143	        k+=_eed;
				;144	        
				;145	        _eea=0x13;
				;146	        _mp1=0x40;
				;147	        _bp=1;
				;148	        asm("set %0.1":"=m"(_iar1));
				;149	        asm("set %0.0":"=m"(_iar1));
				;150	        while(_iar1&0x01) ;
				;151	        _iar1=0;
				;152	        _bp=0;
				;153	        k+=_eed;            
				;154	
				;155	 //       if(cleanCnt == k) 
				;156	 //       	break;
				;157	//        cleanCnt=k;
				;158	    }*/
				;159	}
				;160	
				;161	void PowerDownFunc(void)
				;162	{
				_PowerDownFunc:
				_PowerDownFunc:
0002	0003	ret
0003	0000	nop
				;163	/*    if(NoZeroTime > 12)	//After 50 ms ,enter power down mode 
				;164	    {
				;165			if(!PowerDnFlag) 
				;166			{
				;167			    PowerDnFlag = true;
				;168				WriteEepRom();
				;169				//				;170			}
				;171	    }
				;172	    else
				;173	    {
				;174	     	if(PowerDnFlag)   
				;175			{
				;176	            if(NoZeroTime  < 5)	//				;177	            	NoZeroTime = false;  	
				;178			}
				;179	    }*/
				;180	}
				;file E:\				;1	#include "base.h"
				;2	#define EXTERN extern
				;3	#include "Var.h"
				;4	
				;5	
				;6	/*********************************************************************************************************
				;7	** 				;8	** 				;9	** 				;10	** 				;11	** 				;12	** 				;13	********************************************************************************************************/
				;14	void __attribute((interrupt(0x10))) ISR_tmr2 (void)
				;15	{
				@dummy12 .SECTION 'CODE'
				@ISR_tmr2_code .SECTION 'CODE'
0010	40DD	mov     r110, a
0011	070A	mov     a, STATUS
0012	40DE	mov     r210, a
0013	2BC8	jmp     _ISR_tmr2
				@dummy16 .SECTION 'CODE'
0014	0000	nop
0015	0000	nop
0016	0000	nop
0017	0000	nop
0018	0000	nop
0019	0000	nop
001A	0000	nop
001B	0000	nop
				;16	//	_pc0 = !_pc0;
				;17	//	_pb4 = !_pb4;	
				;18	    _mf1f = 0;
				_ISR_tmr2:
				_ISR_tmr2:
03C8	360F	clr     MF1F
				;19	    _t2pf = 0;
03C9	3712	clr     T2PF
				;20	    _t1pf = 0;
03CA	3612	clr     T1PF
				;21	    //if(mfPumpW==0)
				;22	    if(1)
				;23	    {
				;24	        _t2cp = 0;
03CB	3519	clr     T2CP
				;25	        //_tm2al = 0;
				;26	        //_tm2ah = 0;
				;27	        _pb3 = 0;
03CC	35A5	clr     PB3
				;28	    }
				;29	    else
				;30	    {
				;31	//        _tm2al = (unsigned char)pumpPwm;
				;32	//        _tm2ah = (unsigned char)(pumpPwm>>8);
				;33	        _t2cp = 1;
				;34	    }
				;35		TaskChkLoadRdy = true;
03CD	72BE	set     maiFlagB[0].5
				;36		_t2on = false;							// turn off timer 0 to change timer config		
03CE	35A8	clr     T2ON
03CF	475E	mov     a, r210
03D0	008A	mov     STATUS, a
03D1	475D	mov     a, r110
03D2	0004	reti
				;37	
				;38	}
				;39	
				;40	/*********************************************************************************************************
				;41	** 				;42	** 				;43	** 				;44	** 				;45	** 				;46	** 				;47	********************************************************************************************************/
				;48	void __attribute((interrupt(0x0c))) ISR_tmr0 (void)
				;49	{
				L000C:
				@ISR_tmr0_code .SECTION 'CODE'
000C	40DF	mov     r10c, a
000D	070A	mov     a, STATUS
000E	40E0	mov     r20c, a
000F	2BD3	jmp     _ISR_tmr0
				;50		// off the pump pulse if triac is ON
				;51		// on the pump pulse if triac is off before zero cross
				;52		if(IO_HEATTR)
				_ISR_tmr0:
				_ISR_tmr0:
03D3	3B14	snz     PA6
03D4	2BDC	jmp     _L3
				;53		{											// off the pump if Triac is ON					
				;54			_t0on = false;							// turn off timer 0 to change timer config
03D5	35AF	clr     T0ON
				;55			IO_HEATTR = false;
03D6	3714	clr     PA6
				;56			_tm0al=0x13;		               		// set TM0 CCRA=875; Timer interval = 875/125kHz=7ms
03D7	0F13	mov     a, 13H
03D8	00B3	mov     TM0AL, a
				;57			_tm0ah=0x03; 	                    
03D9	0F03	mov     a, 3H
03DA	00B4	mov     TM0AH, a
03DB	2BE4	jmp     _L5
				;58			_t0on = true;							// turn on Timer0 and reset the timer count
				;59		}
				;60		else if (!ZeroHalfFlag)
				_L3:
03DC	7EBC	sz      LEDH[0].5
03DD	2BE5	jmp     _L4
				;61		{											// on the pump pulse before next zero cross
				;62			_t0on = false;							// turn off timer 0 to change timer config
03DE	35AF	clr     T0ON
				;63			IO_HEATTR = true;
03DF	3314	set     PA6
				;64			ZeroHalfFlag = true;					// 
03E0	72BC	set     LEDH[0].5
				;65			_tm0al=0xfa;		                	// set TM0 CCRA=250; Timer interval = 250/125kHz=2ms
03E1	0FFA	mov     a, FAH
03E2	00B3	mov     TM0AL, a
				;66			_tm0ah=0x00; 	                    
03E3	1F34	clr     TM0AH
				;67			_t0on = true;							// turn on Timer0 and reset the timer count
				_L5:
03E4	31AF	set     T0ON
				;68		}
				;69		_t0af=0;									// clr TM0 Comparator A match interrupt req flg.		
				_L4:
03E5	3691	clr     T0AF
03E6	4760	mov     a, r20c
03E7	008A	mov     STATUS, a
03E8	475F	mov     a, r10c
03E9	0004	reti
				;70	}
				;71	/*********************************************************************************************************
				;72	** 				;73	** 				;74	** 				;75	** 				;76	** 				;77	** 				;78	********************************************************************************************************/
				;79	
				;80	#define INIT_NO_DETECT_TIME	3
				;81	unsigned char Time500Cnt = 0,Time1SCnt = 0,Time100Cnt = 0;
				;82	void __attribute((interrupt(0x1c))) ISRTime0Base(void)
				;83	{
				@ISRTime0Base_code .SECTION 'CODE'
001C	40E1	mov     r11c, a
001D	070A	mov     a, STATUS
001E	40E2	mov     r21c, a
001F	2BEA	jmp     _ISRTime0Base
				;84		static u8 TaskADCCnt = 0;
				;85		
				;86		NoZeroTime++;				//				_ISRTime0Base:
				_ISRTime0Base:
03EA	4726	mov     a, NoZeroTime[0]
03EB	40E3	mov     ra1c, a
03EC	5463	inca    ra1c
03ED	40A6	mov     NoZeroTime[0], a
				;87		TaskADCCnt++;
03EE	5453	inca    TaskADCCnt[0]
03EF	40E4	mov     rb1c, a
03F4	4764	mov     a, rb1c
03F5	40D3	mov     TaskADCCnt[0], a
03F6	2BF9	jmp     _L9
				;88		if(TaskADCCnt > 25)			//100ms03F0	0F19	mov     a, 19H
03F1	4264	sub     a, rb1c
03F2	380A	snz     C
03F3	2BF7	jmp     _L8
				;89		{
				;90			TaskADCCnt = 0;
				_L8:
03F7	5F53	clr     TaskADCCnt[0]
				;91			TaskADCRdyFlag = true;
03F8	70BE	set     maiFlagB[0].1
				;92		}
				;93		if((Time100Cnt ++) >= 25)
				_L9:
03F9	4750	mov     a, Time100Cnt[0]
03FA	40E4	mov     rb1c, a
03FB	0F18	mov     a, 18H
03FC	4264	sub     a, rb1c
03FD	380A	snz     C
03FE	2C02	jmp     _L10
03FF	5464	inca    rb1c
0400	40D0	mov     Time100Cnt[0], a
0401	2C0B	jmp     _L11
				;94		{
				;95			Time100Cnt = 0;
				_L10:
0402	5F50	clr     Time100Cnt[0]
				;96			Flag100ms = !Flag100ms;
0403	473E	mov     a, maiFlagB[0]
0404	0C10	xor     a, 10H
0405	40E4	mov     rb1c, a
0406	0F10	mov     a, 10H
0407	46E4	andm    a, rb1c
0408	763E	clr     maiFlagB[0].4
0409	4764	mov     a, rb1c
040A	45BE	orm     a, maiFlagB[0]
				;97		}
				;98		
				;99		if(Time500Cnt++ >= 122)		//500ms				_L11:
040B	4752	mov     a, Time500Cnt[0]
040C	40E4	mov     rb1c, a
040D	0F79	mov     a, 79H
040E	4264	sub     a, rb1c
040F	380A	snz     C
0410	2C14	jmp     _L12
0411	5464	inca    rb1c
0412	40D2	mov     Time500Cnt[0], a
0413	2C16	jmp     _L13
				;100		{
				;101			Time500Cnt = 0;
				_L12:
0414	5F52	clr     Time500Cnt[0]
				;102			Flag500ms = true;
0415	71BF	set     maiFlagA[0].3
				;103		//	LED_RED = !LED_RED;
				;104		}
				;105	
				;106		if(Time1SCnt++ >= 240)		//1S				_L13:
0416	4751	mov     a, Time1SCnt[0]
0417	40E4	mov     rb1c, a
0418	5464	inca    rb1c
0419	40D1	mov     Time1SCnt[0], a
041A	0FEF	mov     a, EFH
041B	4264	sub     a, rb1c
041C	3C0A	sz      C
041D	2C35	jmp     _L15
				;107		{
				;108			Time1SCnt = 0;
041E	5F51	clr     Time1SCnt[0]
				;109			Time1MinCnt++;
041F	5436	inca    Time1MinCnt[0]
0420	40E7	mov     _ISRTime0Base_2, a
0421	4767	mov     a, _ISRTime0Base_2
0422	40B6	mov     Time1MinCnt[0], a
				;110			NoZeroTime++;
0423	4763	mov     a, ra1c
0424	0B02	add     a, 2H
0425	40A6	mov     NoZeroTime[0], a
				;111			Flag1S = true;
0426	703E	set     maiFlagB[0].0
				;112			if(Time1MinCnt > INIT_NO_DETECT_TIME)
0427	0F03	mov     a, 3H
0428	4267	sub     a, _ISRTime0Base_2
0429	3C0A	sz      C
042A	2C32	jmp     _L17
				;113			{
				;114				FlagStartDetect = true;				
042B	73BF	set     maiFlagA[0].7
				;115			}
				;116			if(Time1MinCnt >= 60)	//042C	0F3B	mov     a, 3BH
042D	4267	sub     a, _ISRTime0Base_2
042E	3C0A	sz      C
042F	2C32	jmp     _L17
				;117			{
				;118				Time1MinCnt = 0;
0430	5F36	clr     Time1MinCnt[0]
				;119				Time60Min++;
0431	54B9	inc     Time60Min[0]
				;120			}
				;121			if(ModeScntFlag)	//				_L17:
0432	7A3C	snz     LEDH[0].4
0433	2C35	jmp     _L15
				;122			{
				;123				ModeScnt++;
0434	54A7	inc     ModeScnt[0]
				;124			}
				;125		}
				;126		if(WorkMode != POWERON_MODE)
				_L15:
0435	50B4	sz      WorkMode[0]
0436	2C38	jmp     _LI1
0437	2C39	jmp     _L7
				;127			TaskKeyRdy = true;
				_LI1:
0438	72BD	set     LEDG[0].5
				_L7:
0439	4762	mov     a, r21c
043A	008A	mov     STATUS, a
043B	4761	mov     a, r11c
043C	0004	reti
				;128	}
				;129	
				;130	
				;131	void __attribute((interrupt(0x20))) ISRTime1Base(void)
				;132	{
				_ISRTime1Base:
				@ISRTime1Base_code .SECTION 'CODE'
				@dummy28 .SECTION 'CODE'
0020	0004	reti
				;133	
				;134	}
				;135	
				;136	/*********************************************************************************************************
				;137	** 				;138	** 				;139	** 				;140	** 				;141	** 				;142	** 				;143	********************************************************************************************************/
				;144	const u8 Table_1[]={1,2};		//60HZ	//				;145	
				;146	void __attribute((interrupt(0x04))) ISR_int0 (void)
				;147	{
				@ISR_int0_code .SECTION 'CODE'
0004	40E5	mov     r104, a
0005	070A	mov     a, STATUS
0006	40E6	mov     r204, a
0007	2C3D	jmp     _ISR_int0
				@dummy4 .SECTION 'CODE'
0008	0000	nop
0009	0000	nop
000A	0000	nop
000B	0000	nop
				;148	    _int0f=0;
				_ISR_int0:
				_ISR_int0:
043D	360E	clr     INT0F
				;149	    NoZeroTime = 0;
043E	5F26	clr     NoZeroTime[0]
				;150	    ZeroFlag  = false;
043F	743F	clr     maiFlagA[0].0
				;151		if(EnThyOutFlag && (WorkMode == RUN_MODE))			//0440	7A3F	snz     maiFlagA[0].4
0441	2C51	jmp     _L26
0442	4734	mov     a, WorkMode[0]
0443	0A02	sub     a, 2H
0444	390A	snz     Z
0445	2C51	jmp     _L26
				;152		{
				;153			IO_HEATTR = true;					//0446	3314	set     PA6
				;154			//**setup value of timer 0 int for off pulse 
				;155			_t0on = false;						// turn off timer 0 to change timer config
0447	35AF	clr     T0ON
				;156			_t0af = false;_t0ae = 1;			// enable TM0 Comparator A match interrupt control; clr TM0 Comparator A match interrupt req flg.
0448	3691	clr     T0AF
0449	3091	set     T0AE
				;157			_tm0al = 0xfa;		               	// set TM0 CCRA=250; Timer interval = 250/125kHz=2ms
044A	0FFA	mov     a, FAH
044B	00B3	mov     TM0AL, a
				;158			_tm0ah = 0x00; 	                    
044C	1F34	clr     TM0AH
				;159			_t0on = true;						// turn on Timer0 and reset the timer count
044D	31AF	set     T0ON
				;160			
				;161			
				;162					
				;163			ZeroHalfFlag = false;
044E	76BC	clr     LEDH[0].5
				;164			HeaterFlag = true;			//044F	72BF	set     maiFlagA[0].5
0450	2C54	jmp     _L27
				;165		}
				;166		else						//				;167		{
				;168			_t0on = false;							// turn off timer 0 to change timer config		
				_L26:
0451	35AF	clr     T0ON
				;169			IO_HEATTR = false;		//0452	3714	clr     PA6
				;170			HeaterFlag = false;		//0453	76BF	clr     maiFlagA[0].5
				;171		}  
				;172		
				;173		//				;174		_t2on = false;						// turn off timer 0 to change timer config
				_L27:
0454	35A8	clr     T2ON
				;175		_t2af = false;_t2ae = 1;			// enable TM0 Comparator A match interrupt control; clr TM0 Comparator A match interrupt req flg.
0455	3792	clr     T2AF
0456	3192	set     T2AE
				;176		_tm2al = 0x06;		               	// set TM0 CCRA=0x0206; Timer interval = 0x0206/125kHz=4.3ms
0457	0F06	mov     a, 6H
0458	00AC	mov     TM2AL, a
				;177		_tm2ah = 0x02; 	                    
0459	0F02	mov     a, 2H
045A	00AD	mov     TM2AH, a
				;178		_t2on = true;						// turn on Timer0 and reset the timer count
045B	31A8	set     T2ON
045C	4766	mov     a, r204
045D	008A	mov     STATUS, a
045E	4765	mov     a, r104
045F	0004	reti
				;179		  
				;180	}
				;file E:\				;1	;;--------------------------------------------------------------;;
				;2	;;    This file is part of the Holtek C Compiler V3 package     ;;
				;3	;;    For the initialization of static linkage variables        ;;
				;4	;;    Copyright (C) 2017 Holtek Semiconductor Inc.              ;;
				;5	;;    Version: 1.07 (Above IDE3000 V7.94)                       ;;
				;6	;;    Date:    2017/03/06                                        ;;
				;7	;;--------------------------------------------------------------;;
				;8	
				;9	acc equ [05h]
				;10	tblp equ [07h]
				;11	tblh equ [08h]
				;12	;;tbhp equ [09h] 
				;13	r0 equ [00h]
				;14	mp0 equ [01h]
				;15	r1 equ [02h]
				;16	mp1l equ [03h]
				;17	mp1h equ [04h]
				;18	z equ [0ah].2
				;19	c equ [0ah].0
				;20	
				;21	ifndef tbhp
				;22	tbhp equ [09h]
				;23	endif
				;24	 
				;25	extern startup_value_1:near
				;26	
				;27	@start .section 'code'
				;28	begin_startup_value:
				;29	  mov a,low (offset startup_value_1) 
				begin_startup_value:
				@start .SECTION 'CODE'
				_main_startup1:
				@start .SECTION 'CODE'
0021	0F5B	mov     a, 5BH
				;30	  mov tblp,a
0022	0087	mov     TBLP, a
				;31	  mov a,high (offset startup_value_1) 
0023	0F00	mov     a, 0H
				;32	  mov tbhp,a
0024	0089	mov     TBHP, a
				;33	next_table:
				;34	  ;CLR WDT
				;35	  inc tblp
				next_table:
0025	1487	inc     TBLP
				;36	  sz z
0026	3D0A	sz      Z
				;37	  inc tbhp
0027	1489	inc     TBHP
				;38	ifdef USE_TABRDC
				;39	  tabrdc mp0
				;40	else
				;41	  tabrd mp0
0028	1D01	tabrd   MP0
				;42	endif
				;43	  sz mp0
0029	1081	sz      MP0
				;44	  jmp read_data
002A	282C	jmp     read_data
				;45	  jmp startupend1
002B	2841	jmp     startupend1
				;46	read_data:
				;47	  inc tblp
				read_data:
002C	1487	inc     TBLP
				;48	  sz z
002D	3D0A	sz      Z
				;49	  inc tbhp
002E	1489	inc     TBHP
				;50	ifdef USE_TABRDC
				;51	  tabrdc mp1l
				;52	else
				;53	  tabrd mp1l
002F	1D03	tabrd   MP1
				;54	endif
				;55	  mov a,tblh
0030	0708	mov     a, TBLH
				;56	  mov mp1h,a
0031	0084	mov     BP, a
				;57	next_data:
				;58	  inc tblp
				next_data:
0032	1487	inc     TBLP
				;59	  sz z
0033	3D0A	sz      Z
				;60	  inc tbhp
0034	1489	inc     TBHP
				;61	ifdef USE_TABRDC
				;62	  tabrdc acc
				;63	else
				;64	  tabrd acc
0035	1D05	tabrd   ACC
				;65	endif
				;66	  mov r1,a
0036	0082	mov     [02H], a
				;67	  sdz mp0
0037	1781	sdz     MP0
				;68	  jmp $+2
0038	283A	jmp     L003A
				;69	  jmp next_table
0039	2825	jmp     next_table
				;70	  inc mp1l
				L003A:
003A	1483	inc     MP1
				;71	  mov a,tblh
003B	0708	mov     a, TBLH
				;72	  mov r1,a
003C	0082	mov     [02H], a
				;73	  inc mp1l
003D	1483	inc     MP1
				;74	  sdz mp0
003E	1781	sdz     MP0
				;75	  jmp next_data
003F	2832	jmp     next_data
				;76	  jmp next_table
0040	2825	jmp     next_table
				;77	
				;78	;end_startup_value:
				;79	
				;80	startupend1:
				;81	ifndef Disable_Bit_Initial
				;82		MOV A,high  bitdatasec1_start
				startupend1:
0041	0F00	mov     a, 0H
				;83		MOV mp1h,a
0042	0084	mov     BP, a
				;84		MOV A,offset bitdatasec1_end
0043	0FC0	mov     a, C0H
				;85		mov mp1l,A
0044	0083	mov     MP1, a
				;86		dec mp1l
0045	1583	dec     MP1
				;87		clr z
0046	350A	clr     Z
				;88		sub a,offset bitdatasec1_start
0047	0AC0	sub     a, C0H
				;89		sz z
0048	3D0A	sz      Z
				;90		jmp startupend2
0049	284E	jmp     startupend2
				;91	L0005:
				;92		set r1
				L0005:
004A	1F82	set     [02H]
				;93		dec mp1l
004B	1583	dec     MP1
				;94		sdz  acc
004C	1785	sdz     ACC
				;95		jmp L0005
004D	284A	jmp     L0005
				;96	
				;97	startupend2:
				;98		MOV A,high  bitdatasec0_start
				startupend2:
004E	0F00	mov     a, 0H
				;99		MOV mp1h,a
004F	0084	mov     BP, a
				;100		MOV A,offset bitdatasec0_end
0050	0FC0	mov     a, C0H
				;101		mov mp1l,A
0051	0083	mov     MP1, a
				;102		dec mp1l
0052	1583	dec     MP1
				;103		clr z
0053	350A	clr     Z
				;104		sub a,offset bitdatasec0_start
0054	0AC0	sub     a, C0H
				;105		sz  z
0055	3D0A	sz      Z
				;106		jmp startupend3
0056	285B	jmp     startupend3
				;107	L0006:
				;108		clr r1
				L0006:
0057	1F02	clr     [02H]
				;109		dec mp1l
0058	1583	dec     MP1
				;110		sdz  acc
0059	1785	sdz     ACC
				;111		jmp L0006
005A	2857	jmp     L0006
				;112	startupend3:
				;113	endif		
				;114	   
				;115	@ROMDATA_BASE .SECTION com_l 'CODE'  
				;116	startup_value:
				;117	;;linker range the initial value table here
				;118	
				;119	@BITDATASEC1 .SECTION com_l 'DATA'  
				;120	bitdatasec1_start:
				;121	
				;122	@BITDATASEC1 .SECTION com_e 'DATA'  
				;123	bitdatasec1_end:
				;124	
				;125	@BITDATASEC .SECTION com_l 'DATA'  
				;126	bitdatasec0_start:
				;127	
				;128	@BITDATASEC .SECTION com_e 'DATA'  
				;129	bitdatasec0_end:
				;file E:\				;1	#include "base.h"
				;2	#define EXTERN extern
				;3	#include "Var.h"
				;4	
				;5	typedef struct
				;6	{
				;7		u16 Min;
				;8		u16 Max;
				;9	}__TEMP;
				;10	
				;11	#define PVC_PTC			1		//0 PVC 1 PTC
				;12	
				;13	#define MIN_VALU		500		//				;14	
				;15	#define BASE_40C		1391	//37
				;16	#define MID_40C			1502
				;17	#define HIGH_40C		1468	//41
				;18	
				;19	
				;20	#define BASE_50C		1584	//47
				;21	#define MID_50C			1642
				;22	#define HIGH_50C		1661	//51
				;23	
				;24	#define BASE_60C		1793	//58
				;25	#define MID_60C			1830
				;26	#define HIGH_60C		1923	//65
				;27	
				;28	#define SHORT_VALU		100
				;29	
				;30	unsigned short k;
				;31	
				;32	 __TEMP TempArray[3] = 
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
005E	056F	or      a, __pcpu[45]
005F	05BC	orm     a, TM1RPL
0060	0630	and     a, TM0C1
0061	067D	and     a, __pcpu[59]
0062	0701	mov     a, MP0
0063	0783	dc	00783H
0064	0005	clr     wdt2
0065	00CE	mov     __pcpu[12], a
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
0066	0000	nop
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
0067	0000	nop
0068	0000	nop
0069	0000	nop
				;33	{
				;34		{BASE_40C,HIGH_40C},
				;35		{BASE_50C,HIGH_50C},
				;36		{BASE_60C,HIGH_60C}
				;37	};
				;38	
				;39	
				;40	void GetPTCValu(void)
				;41	{
				;42		unsigned char i;
				;43		unsigned short min,max;
				;44		volatile static unsigned short adcBuf[10] __attribute__ ((at(0x1c0)));
				;45	
				;46		_adcr0 = ADC_PTC1;			//				_GetPTCValu:
				_GetPTCValu:
				@dummy .SECTION 'CODE'
0083	0F11	mov     a, 11H
0084	00A2	mov     ADCR0, a
				;47		STAR_ADC();
0085	37A2	clr     START
0086	33A2	set     START
0087	37A2	clr     START
				;48		while(_eocb);
				_L3:
0088	3F22	sz      EOCB
0089	2888	jmp     _L3
				;49	    
				;50	    k = _adrh;
				;51	    k <<= 8;
008A	0721	mov     a, ADRH
008B	40D7	mov     rc, a
008C	5F56	clr     rb
				;52	    k += _adrl;
008D	0720	mov     a, ADRL
008E	43D6	addm    a, rb
008F	3C0A	sz      C
0090	54D7	inc     rc
0091	4756	mov     a, rb
0092	40CC	mov     k[0], a
0093	4757	mov     a, rc
0094	40CD	mov     k[1], a
				;53	    if(adcsp < 10) 
0095	4738	mov     a, adcsp[0]
0096	40E8	mov     _GetSwitch_2, a
0097	0F09	mov     a, 9H
0098	4268	sub     a, _GetSwitch_2
0099	3C0A	sz      C
009A	289F	jmp     _L13
				;54	    	i = adcsp;
				;55	    else  
				;56	    	i = adcsp - 10;
009B	4768	mov     a, _GetSwitch_2
009C	0BF6	add     a, F6H
009D	40D8	mov     rd, a
009E	28A1	jmp     _L4
				_L13:
009F	4768	mov     a, _GetSwitch_2
00A0	40D8	mov     rd, a
				;57	    adcBuf[i] = k;
				_L4:
00A1	5F59	clr     re
00A2	340A	clr     C
00A3	5AD8	rlc     rd
00A4	5AD9	rlc     re
00A5	0FC0	mov     a, C0H
00A6	4358	add     a, rd
00A7	0083	mov     MP1, a
00A8	0F01	mov     a, 1H
00A9	5359	adc     a, re
00AA	0081	mov     MP0, a
00AB	0701	mov     a, MP0
00AC	0084	mov     BP, a
00AD	4756	mov     a, rb
00AE	0082	mov     [02H], a
00AF	1483	inc     MP1
00B0	4757	mov     a, rc
00B1	0082	mov     [02H], a
				;58	    if(adcsp < 11) 				//00B2	0F0A	mov     a, AH
00B3	4268	sub     a, _GetSwitch_2
00B4	380A	snz     C
00B5	28B9	jmp     _L5
				;59	    {
				;60	    	adcsp++; 
00B6	5468	inca    _GetSwitch_2
00B7	40B8	mov     adcsp[0], a
				;61	    	return;
00B8	297E	jmp     _L1
				;62	    }
				;63	    adcsp = 0;
				_L5:
00B9	5F38	clr     adcsp[0]
				;64	    k = adcBuf[0];
00BA	0FC0	mov     a, C0H
00BB	0083	mov     MP1, a
00BC	0F01	mov     a, 1H
00BD	0081	mov     MP0, a
00BE	0701	mov     a, MP0
00BF	0084	mov     BP, a
00C0	0702	mov     a, [02H]
00C1	40DA	mov     rf, a
00C2	1483	inc     MP1
00C3	0702	mov     a, [02H]
00C4	40DB	mov     rg, a
00C5	475A	mov     a, rf
00C6	40EC	mov     _GetSwitch_2[4], a
00C7	475B	mov     a, rg
00C8	40ED	mov     _GetSwitch_2[5], a
00CD	0F09	mov     a, 9H
00CE	40DC	mov     rh, a
				;65	    min = k;
00C9	475A	mov     a, rf
00CA	40E8	mov     _GetSwitch_2, a
00CB	475B	mov     a, rg
00CC	40E9	mov     _GetSwitch_2[1], a
				;66	    max = k;
				;67	    for(i=1;i<10;i++)
00CF	0F01	mov     a, 1H
00D0	40D5	mov     ra, a
0123	54D5	inc     ra
0124	57DC	sdz     rh
0125	2927	jmp     _LI1
0126	292C	jmp     _L9
				;68	    {
				;69	        if(min > adcBuf[i])  
				_L10:
00D1	4755	mov     a, ra
00D2	40D6	mov     rb, a
00D3	5F57	clr     rc
00D4	340A	clr     C
00D5	5A56	rlca    rb
00D6	40D8	mov     rd, a
00D7	5A57	rlca    rc
00D8	40D9	mov     re, a
00D9	0FC0	mov     a, C0H
00DA	43D8	addm    a, rd
00DB	0F01	mov     a, 1H
00DC	53D9	adcm    a, re
00DD	4758	mov     a, rd
00DE	0083	mov     MP1, a
00DF	4759	mov     a, re
00E0	0081	mov     MP0, a
00E1	24D9	call    L04D9
00E2	40EA	mov     _GetSwitch_2[2], a
00E3	24D8	call    L04D8
00E4	40EB	mov     _GetSwitch_2[3], a
00E5	476A	mov     a, _GetSwitch_2[2]
00E6	4268	sub     a, _GetSwitch_2
00E7	476B	mov     a, _GetSwitch_2[3]
00E8	5269	sbc     a, _GetSwitch_2[1]
00E9	3C0A	sz      C
00EA	28F3	jmp     _L7
				;70	        	min = adcBuf[i];
00EB	4758	mov     a, rd
00EC	0083	mov     MP1, a
00ED	4759	mov     a, re
00EE	0081	mov     MP0, a
00EF	24D9	call    L04D9
00F0	40E8	mov     _GetSwitch_2, a
00F1	24D8	call    L04D8
00F2	40E9	mov     _GetSwitch_2[1], a
				;71	        if(max < adcBuf[i])  
				_L7:
00F3	340A	clr     C
00F4	5A56	rlca    rb
00F5	40D8	mov     rd, a
00F6	5A57	rlca    rc
00F7	40D9	mov     re, a
00F8	0FC0	mov     a, C0H
00F9	43D8	addm    a, rd
00FA	0F01	mov     a, 1H
00FB	53D9	adcm    a, re
00FC	4758	mov     a, rd
00FD	0083	mov     MP1, a
00FE	4759	mov     a, re
00FF	0081	mov     MP0, a
0100	24D9	call    L04D9
0101	40EA	mov     _GetSwitch_2[2], a
0102	24D8	call    L04D8
0103	40EB	mov     _GetSwitch_2[3], a
0104	475A	mov     a, rf
0105	426A	sub     a, _GetSwitch_2[2]
0106	475B	mov     a, rg
0107	526B	sbc     a, _GetSwitch_2[3]
0108	3C0A	sz      C
0109	2912	jmp     _L8
				;72	        	max = adcBuf[i];
010A	4758	mov     a, rd
010B	0083	mov     MP1, a
010C	4759	mov     a, re
010D	0081	mov     MP0, a
010E	24D9	call    L04D9
010F	40DA	mov     rf, a
0110	24D8	call    L04D8
0111	40DB	mov     rg, a
				;73	        k += adcBuf[i]; 
				_L8:
0112	340A	clr     C
0113	5AD6	rlc     rb
0114	5AD7	rlc     rc
0115	0FC0	mov     a, C0H
0116	4356	add     a, rb
0117	0083	mov     MP1, a
0118	0F01	mov     a, 1H
0119	5357	adc     a, rc
011A	0081	mov     MP0, a
011B	24D9	call    L04D9
011C	40D6	mov     rb, a
011D	24D8	call    L04D8
011E	40D7	mov     rc, a
011F	476C	mov     a, _GetSwitch_2[4]
0120	43D6	addm    a, rb
0121	476D	mov     a, _GetSwitch_2[5]
0122	53D7	adcm    a, rc
				_LI1:
0127	4756	mov     a, rb
0128	40EC	mov     _GetSwitch_2[4], a
0129	4757	mov     a, rc
012A	40ED	mov     _GetSwitch_2[5], a
012B	28D1	jmp     _L10
				;74	    }
				;75	    k -= min; k -= max; k >>= 3;			//				_L9:
012C	4756	mov     a, rb
012D	4268	sub     a, _GetSwitch_2
012E	40D6	mov     rb, a
012F	4757	mov     a, rc
0130	5269	sbc     a, _GetSwitch_2[1]
0131	40D7	mov     rc, a
0132	4756	mov     a, rb
0133	425A	sub     a, rf
0134	40D6	mov     rb, a
0135	4757	mov     a, rc
0136	525B	sbc     a, rg
0137	40D7	mov     rc, a
0138	0F03	mov     a, 3H
				_LI2:
0139	340A	clr     C
013A	5BD7	rrc     rc
013B	5BD6	rrc     rb
013C	1785	sdz     ACC
013D	2939	jmp     _LI2
013E	4756	mov     a, rb
013F	40CC	mov     k[0], a
0140	4757	mov     a, rc
0141	40CD	mov     k[1], a
				;76	    
				;77		if(k > TempArray[HeartMode].Max)		//0142	4733	mov     a, HeartMode[0]
0143	40D8	mov     rd, a
0144	5F59	clr     re
0145	340A	clr     C
0146	5A58	rlca    rd
0147	40DA	mov     rf, a
0148	5A59	rlca    re
0149	40DB	mov     rg, a
014A	340A	clr     C
014B	5ADA	rlc     rf
014C	5ADB	rlc     rg
014D	0FC2	mov     a, C2H
014E	435A	add     a, rf
014F	0083	mov     MP1, a
0150	0F00	mov     a, 0H
0151	535B	adc     a, rg
0152	0081	mov     MP0, a
0153	24D9	call    L04D9
0154	40DA	mov     rf, a
0155	24D8	call    L04D8
0156	40DB	mov     rg, a
0157	475A	mov     a, rf
0158	4256	sub     a, rb
0159	475B	mov     a, rg
015A	5257	sbc     a, rc
015B	3C0A	sz      C
015C	295E	jmp     _L11
				;78		{
				;79			EnThyOutFlag = false;
015D	763F	clr     maiFlagA[0].4
				;80		}
				;81		if(k < TempArray[HeartMode].Min)		//				_L11:
015E	340A	clr     C
015F	5AD8	rlc     rd
0160	5AD9	rlc     re
0161	340A	clr     C
0162	5AD8	rlc     rd
0163	5AD9	rlc     re
0164	0FC0	mov     a, C0H
0165	4358	add     a, rd
0166	0083	mov     MP1, a
0167	0F00	mov     a, 0H
0168	5359	adc     a, re
0169	0081	mov     MP0, a
016A	24D9	call    L04D9
016B	40D8	mov     rd, a
016C	24D8	call    L04D8
016D	40D9	mov     re, a
016E	4756	mov     a, rb
016F	4258	sub     a, rd
0170	4757	mov     a, rc
0171	5259	sbc     a, re
0172	3C0A	sz      C
0173	2975	jmp     _L12
				;82		{
				;83			EnThyOutFlag = true;	
0174	723F	set     maiFlagA[0].4
				;84		}
				;85		if((k < MIN_VALU)&&(FlagStartDetect == true))	//				_L12:
0175	0FF3	mov     a, F3H
0176	4256	sub     a, rb
0177	0F01	mov     a, 1H
0178	5257	sbc     a, rc
0179	380A	snz     C
017A	297E	jmp     _L1
017B	7BBF	snz     maiFlagA[0].7
017C	297E	jmp     _L1
				;86		{
				;87			ShortFlag = true;
017D	70BF	set     maiFlagA[0].1
				_L1:
017E	0003	ret
				;88		}    
				;89	    
				;90	}
				;91	
				;92	void GetLoadValu(void)
				;93	{
				;94		unsigned char i;
				;95		unsigned short min,max;
				;96		volatile static unsigned short adc1Buf[10] __attribute__ ((at(0x1d5)));
				;97		
				;98		_adcr0 = ADC_CURRENT;	//				_GetLoadValu:
				_GetLoadValu:
017F	0F13	mov     a, 13H
0180	00A2	mov     ADCR0, a
				;99		STAR_ADC();
0181	37A2	clr     START
0182	33A2	set     START
0183	37A2	clr     START
				;100		while(_eocb);	
				_L20:
0184	3F22	sz      EOCB
0185	2984	jmp     _L20
				;101	    k = _adrh;
				;102	    k <<= 8;
0186	0721	mov     a, ADRH
0187	40D7	mov     rc, a
0188	5F56	clr     rb
				;103	    k += _adrl;
0189	0720	mov     a, ADRL
018A	43D6	addm    a, rb
018B	3C0A	sz      C
018C	54D7	inc     rc
018D	4756	mov     a, rb
018E	40CC	mov     k[0], a
018F	4757	mov     a, rc
0190	40CD	mov     k[1], a
				;104	    if(AdcCnt < 10) 
0191	4720	mov     a, AdcCnt[0]
0192	40E8	mov     _GetSwitch_2, a
0193	0F09	mov     a, 9H
0194	4268	sub     a, _GetSwitch_2
0195	3C0A	sz      C
0196	299B	jmp     _L33
				;105	    	i = AdcCnt;
				;106	    else  
				;107	    	i = AdcCnt - 10;
0197	4768	mov     a, _GetSwitch_2
0198	0BF6	add     a, F6H
0199	40D8	mov     rd, a
019A	299D	jmp     _L21
				_L33:
019B	4768	mov     a, _GetSwitch_2
019C	40D8	mov     rd, a
				;108	    adc1Buf[i] = k;
				_L21:
019D	5F59	clr     re
019E	340A	clr     C
019F	5AD8	rlc     rd
01A0	5AD9	rlc     re
01A1	0FD5	mov     a, D5H
01A2	4358	add     a, rd
01A3	0083	mov     MP1, a
01A4	0F01	mov     a, 1H
01A5	5359	adc     a, re
01A6	0081	mov     MP0, a
01A7	0701	mov     a, MP0
01A8	0084	mov     BP, a
01A9	4756	mov     a, rb
01AA	0082	mov     [02H], a
01AB	1483	inc     MP1
01AC	4757	mov     a, rc
01AD	0082	mov     [02H], a
				;109	    if(AdcCnt < 11) 	//01AE	0F0A	mov     a, AH
01AF	4268	sub     a, _GetSwitch_2
01B0	380A	snz     C
01B1	29B5	jmp     _L22
				;110	    {
				;111	    	AdcCnt++; 
01B2	5468	inca    _GetSwitch_2
01B3	40A0	mov     AdcCnt[0], a
				;112	    	return;
01B4	2A69	jmp     _L18
				;113	    }
				;114	    AdcCnt = 0;
				_L22:
01B5	5F20	clr     AdcCnt[0]
				;115	    k = adc1Buf[0];
01B6	0FD5	mov     a, D5H
01B7	0083	mov     MP1, a
01B8	0F01	mov     a, 1H
01B9	0081	mov     MP0, a
01BA	0701	mov     a, MP0
01BB	0084	mov     BP, a
01BC	0702	mov     a, [02H]
01BD	40DA	mov     rf, a
01BE	1483	inc     MP1
01BF	0702	mov     a, [02H]
01C0	40DB	mov     rg, a
01C1	475A	mov     a, rf
01C2	40EC	mov     _GetSwitch_2[4], a
01C3	475B	mov     a, rg
01C4	40ED	mov     _GetSwitch_2[5], a
01C9	0F09	mov     a, 9H
01CA	40DC	mov     rh, a
				;116	    min = k;
01C5	475A	mov     a, rf
01C6	40E8	mov     _GetSwitch_2, a
01C7	475B	mov     a, rg
01C8	40E9	mov     _GetSwitch_2[1], a
				;117	    max = k;
				;118	    for(i=1;i<10;i++)
01CB	0F01	mov     a, 1H
01CC	40D5	mov     ra, a
021F	54D5	inc     ra
0220	57DC	sdz     rh
0221	2A23	jmp     _LI3
0222	2A28	jmp     _L26
				;119	    {
				;120	        if(min > adc1Buf[i])  
				_L27:
01CD	4755	mov     a, ra
01CE	40D6	mov     rb, a
01CF	5F57	clr     rc
01D0	340A	clr     C
01D1	5A56	rlca    rb
01D2	40D8	mov     rd, a
01D3	5A57	rlca    rc
01D4	40D9	mov     re, a
01D5	0FD5	mov     a, D5H
01D6	43D8	addm    a, rd
01D7	0F01	mov     a, 1H
01D8	53D9	adcm    a, re
01D9	4758	mov     a, rd
01DA	0083	mov     MP1, a
01DB	4759	mov     a, re
01DC	0081	mov     MP0, a
01DD	24D9	call    L04D9
01DE	40EA	mov     _GetSwitch_2[2], a
01DF	24D8	call    L04D8
01E0	40EB	mov     _GetSwitch_2[3], a
01E1	476A	mov     a, _GetSwitch_2[2]
01E2	4268	sub     a, _GetSwitch_2
01E3	476B	mov     a, _GetSwitch_2[3]
01E4	5269	sbc     a, _GetSwitch_2[1]
01E5	3C0A	sz      C
01E6	29EF	jmp     _L24
				;121	        	min = adc1Buf[i];
01E7	4758	mov     a, rd
01E8	0083	mov     MP1, a
01E9	4759	mov     a, re
01EA	0081	mov     MP0, a
01EB	24D9	call    L04D9
01EC	40E8	mov     _GetSwitch_2, a
01ED	24D8	call    L04D8
01EE	40E9	mov     _GetSwitch_2[1], a
				;122	        if(max < adc1Buf[i])  
				_L24:
01EF	340A	clr     C
01F0	5A56	rlca    rb
01F1	40D8	mov     rd, a
01F2	5A57	rlca    rc
01F3	40D9	mov     re, a
01F4	0FD5	mov     a, D5H
01F5	43D8	addm    a, rd
01F6	0F01	mov     a, 1H
01F7	53D9	adcm    a, re
01F8	4758	mov     a, rd
01F9	0083	mov     MP1, a
01FA	4759	mov     a, re
01FB	0081	mov     MP0, a
01FC	24D9	call    L04D9
01FD	40EA	mov     _GetSwitch_2[2], a
01FE	24D8	call    L04D8
01FF	40EB	mov     _GetSwitch_2[3], a
0200	475A	mov     a, rf
0201	426A	sub     a, _GetSwitch_2[2]
0202	475B	mov     a, rg
0203	526B	sbc     a, _GetSwitch_2[3]
0204	3C0A	sz      C
0205	2A0E	jmp     _L25
				;123	        	max=adc1Buf[i];
0206	4758	mov     a, rd
0207	0083	mov     MP1, a
0208	4759	mov     a, re
0209	0081	mov     MP0, a
020A	24D9	call    L04D9
020B	40DA	mov     rf, a
020C	24D8	call    L04D8
020D	40DB	mov     rg, a
				;124	        k += adc1Buf[i]; 
				_L25:
020E	340A	clr     C
020F	5AD6	rlc     rb
0210	5AD7	rlc     rc
0211	0FD5	mov     a, D5H
0212	4356	add     a, rb
0213	0083	mov     MP1, a
0214	0F01	mov     a, 1H
0215	5357	adc     a, rc
0216	0081	mov     MP0, a
0217	24D9	call    L04D9
0218	40D6	mov     rb, a
0219	24D8	call    L04D8
021A	40D7	mov     rc, a
021B	476C	mov     a, _GetSwitch_2[4]
021C	43D6	addm    a, rb
021D	476D	mov     a, _GetSwitch_2[5]
021E	53D7	adcm    a, rc
				_LI3:
0223	4756	mov     a, rb
0224	40EC	mov     _GetSwitch_2[4], a
0225	4757	mov     a, rc
0226	40ED	mov     _GetSwitch_2[5], a
0227	29CD	jmp     _L27
				;125	    }
				;126	    k -= min; k -= max; k >>= 3;			//				_L26:
0228	4756	mov     a, rb
0229	4268	sub     a, _GetSwitch_2
022A	40D6	mov     rb, a
022B	4757	mov     a, rc
022C	5269	sbc     a, _GetSwitch_2[1]
022D	40D7	mov     rc, a
022E	4756	mov     a, rb
022F	425A	sub     a, rf
0230	40D6	mov     rb, a
0231	4757	mov     a, rc
0232	525B	sbc     a, rg
0233	40D7	mov     rc, a
0234	0F03	mov     a, 3H
				_LI4:
0235	340A	clr     C
0236	5BD7	rrc     rc
0237	5BD6	rrc     rb
0238	1785	sdz     ACC
0239	2A35	jmp     _LI4
023A	4756	mov     a, rb
023B	40CC	mov     k[0], a
023C	4757	mov     a, rc
023D	40CD	mov     k[1], a
				;127	
				;128	    if(FlagStartDetect)						//023E	473F	mov     a, maiFlagA[0]
023F	40E8	mov     _GetSwitch_2, a
0240	7BE8	snz     _GetSwitch_2.7
0241	2A69	jmp     _L18
				;129	    {
				;130	    	if(HeaterFlag)						//0242	7AE8	snz     _GetSwitch_2.5
0243	2A57	jmp     _L29
				;131	    	{
				;132		        if(k > SHORT_VALU)				//0244	0F64	mov     a, 64H
0245	4256	sub     a, rb
0246	0F00	mov     a, 0H
0247	5257	sbc     a, rc
0248	3C0A	sz      C
0249	2A4D	jmp     _L30
				;133		        {
				;134		        	ShortCnt1 = 0;
024A	5F22	clr     ShortCnt1[0]
				;135		        	NoLoadFlag = false;	
024B	753F	clr     maiFlagA[0].2
024C	2A69	jmp     _L18
				;136		        }
				;137		        else
				;138		        {
				;139		        	ShortCnt1++;
				_L30:
024D	5422	inca    ShortCnt1[0]
024E	40D5	mov     ra, a
024F	4755	mov     a, ra
0250	40A2	mov     ShortCnt1[0], a
				;140		        	if(ShortCnt1 >= 200)		//0251	0FC7	mov     a, C7H
0252	4255	sub     a, ra
0253	3C0A	sz      C
0254	2A69	jmp     _L18
				;141		        	{
				;142		        		NoLoadFlag = true;
0255	713F	set     maiFlagA[0].2
0256	2A69	jmp     _L18
				;143		        	}
				;144		        }
				;145	    	}
				;146	    	else								//				;147	    	{
				;148		        if(k < SHORT_VALU)				//				_L29:
0257	0F63	mov     a, 63H
0258	4256	sub     a, rb
0259	0F00	mov     a, 0H
025A	5257	sbc     a, rc
025B	380A	snz     C
025C	2A60	jmp     _L32
				;149		        {
				;150		        	ShortCnt2 = 0;
025D	5F21	clr     ShortCnt2[0]
				;151		        	TRShortFlag = false;	
025E	773E	clr     maiFlagB[0].6
025F	2A69	jmp     _L18
				;152		        }
				;153		        else
				;154		        {
				;155		        	ShortCnt2++;
				_L32:
0260	5421	inca    ShortCnt2[0]
0261	40D5	mov     ra, a
0262	4755	mov     a, ra
0263	40A1	mov     ShortCnt2[0], a
				;156		        	if(ShortCnt2 >= 10)			//0264	0F09	mov     a, 9H
0265	4255	sub     a, ra
0266	3C0A	sz      C
0267	2A69	jmp     _L18
				;157		        	{
				;158		        		TRShortFlag = true;
0268	733E	set     maiFlagB[0].6
				_L18:
0269	0003	ret
				;159		        	}
				;160		        }
				;161	    		
				;162	    	}
				;163	    }	
				;164	}
				;165	/*
				;166	void GetAdcDat(void)
				;167	{
				;168		static u16 ShortCnt = 0;
				;169		unsigned char i;
				;170		unsigned short min,max;
				;171		volatile static unsigned short adcBuf[10] __attribute__ ((at(0x1c0)));
				;172	
				;173	    if(_eocb)  
				;174	    	return;
				;175	
				;176	    k = _adrh;
				;177	    k <<= 8;
				;178	    k += _adrl;
				;179	    if(adcsp < 10) 
				;180	    	i = adcsp;
				;181	    else  
				;182	    	i = adcsp-10;
				;183	    adcBuf[i] = k;
				;184	    if(adcsp < 11) 	//				;185	    {
				;186	    	adcsp++; 
				;187	    	return;
				;188	    }
				;189	    adcsp = 0;
				;190	    k = adcBuf[0];
				;191	    min = k;
				;192	    max = k;
				;193	    for(i=1;i<10;i++)
				;194	    {
				;195	        if(min > adcBuf[i])  
				;196	        	min=adcBuf[i];
				;197	        if(max < adcBuf[i])  
				;198	        	max=adcBuf[i];
				;199	        k += adcBuf[i]; 
				;200	    }
				;201	    k -= min; k -= max; k >>= 3;			//				;202	
				;203	    adcsele++;
				;204	    if(adcsele & 0x01)     					//ADC_HOT
				;205	    {
				;206	        _adcr0 = ADC_PTC1;					//				;207	        STAR_ADC();
				;208	        if(k > TempArray[HeartMode].Max)	//				;209	        {
				;210	        	EnThyOutFlag = false;
				;211	        }
				;212	        if(k < TempArray[HeartMode].Min)	//				;213	        {
				;214	        	EnThyOutFlag = true;	
				;215	        }
				;216			if((k < MIN_VALU)&&(FlagStartDetect == true))	//				;217			{
				;218				ShortFlag = true;
				;219			}
				;220			
				;221	    }
				;222	    else //ADC_WATER
				;223	    {
				;224	        _adcr0=ADC_CURRENT;				//				;225	        STAR_ADC();
				;226	        if((HeaterFlag)&&(FlagStartDetect))					//				;227	        {
				;228		        if(k > SHORT_VALU)			//				;229		        {
				;230		        	ShortCnt = 0;
				;231		        	NoLoadFlag = false;	
				;232		        }
				;233		        else
				;234		        {
				;235		        	ShortCnt++;
				;236		        	if(ShortCnt >= 2000)		//				;237		        	{
				;238		        		//NoLoadFlag = true;
				;239		        		NoLoadFlag = false;
				;240		        	}
				;241		        }
				;242	        }
				;243	    }
				;244	}*/
				;245	
				;file E:\				;1	
				;2	#include "base.h"
				;3	#define EXTERN extern
				;4	#include "Var.h"
				;5	
				;6	void Delay(void)
				;7	{
				;8		u8 i;
				;9		for(i=20;i>0;i--);
				;10	}
				;11	#define HIGH_STA 1
				;12	#define LOW_STA 2
				;13	u8 IOZeroSta = 0,IOZeroStaBak = 0;
				;14	
				;15	void OutCtrl(void)
				;16	{
				;17	/*	if(EnThyOutFlag)	//				;18		{
				;19			if(IO_ZERO)
				;20			{
				;21				Delay();
				;22				if(IO_ZERO)
				;23				{
				;24					IOZeroSta = HIGH_STA;		//				;25					if(IOZeroSta != IOZeroStaBak)
				;26					{
				;27						IOZeroStaBak = IOZeroSta;
				;28						ZeroHalfFlag = true;
				;29					}				
				;30					HeaterFlag = true;			//				;31				}
				;32			}
				;33			else
				;34			{
				;35				IOZeroSta = LOW_STA;
				;36				if(IOZeroSta != IOZeroStaBak)
				;37				{
				;38					IOZeroStaBak = IOZeroSta;
				;39					ZeroHalfFlag = true;
				;40				}
				;41				HeaterFlag = false;			
				;42			}
				;43			if(ZeroHalfFlag)						//				;44			{
				;45				ZeroHalfFlag = false;
				;46				IO_HEATTR = true;
				;47				_t0af = false;_t0ae = 1;			// enable TM0 Comparator A match interrupt control; clr TM0 Comparator A match interrupt req flg.
				;48				_tm0al = 0xfa;		               	// set TM0 CCRA=250; Timer interval = 250/125kHz=2ms
				;49				_tm0ah = 0x00; 	                    
				;50				_t0on = true;						// turn on Timer0 and reset the timer count			
				;51			}
				;52		}
				;53		else
				;54		{
				;55			IO_HEATTR = false;		
				;56			HeaterFlag = false;			
				;57		}*/
				;58	}
				;59	
				;60	#define EN_FLICK	0	//				;61	
				;62	void Func(void)
				;63	{
				;64		if(ShortFlag)		//PTC				_Func:
				_Func:
026A	473F	mov     a, maiFlagA[0]
026B	40E8	mov     _GetSwitch_2, a
026C	78E8	snz     _GetSwitch_2.1
026D	2A76	jmp     _L4
				;65		{
				;66			if(WorkMode != ALARM_MODE)
026E	4734	mov     a, WorkMode[0]
026F	0A03	sub     a, 3H
0270	3D0A	sz      Z
0271	2A76	jmp     _L4
				;67			{
				;68				WorkMode = ALARM_MODE;	//0272	0F03	mov     a, 3H
0273	40B4	mov     WorkMode[0], a
				;69				ErrType = ERR_SHORT;
0274	0F02	mov     a, 2H
0275	40B2	mov     ErrType[0], a
				;70			}
				;71		}
				;72	
				;73		if(NoLoadFlag)		//				_L4:
0276	7968	snz     _GetSwitch_2.2
0277	2A80	jmp     _L5
				;74		{
				;75			if(WorkMode != ALARM_MODE)
0278	4734	mov     a, WorkMode[0]
0279	0A03	sub     a, 3H
027A	3D0A	sz      Z
027B	2A80	jmp     _L5
				;76			{
				;77				WorkMode = ALARM_MODE;	//027C	0F03	mov     a, 3H
027D	40B4	mov     WorkMode[0], a
				;78				ErrType = ERR_NO_LOAD;
027E	0F03	mov     a, 3H
027F	40B2	mov     ErrType[0], a
				;79			}
				;80		}
				;81	
				;82		if(TRShortFlag)
				_L5:
0280	473E	mov     a, maiFlagB[0]
0281	40E9	mov     _GetSwitch_2[1], a
0282	7B69	snz     _GetSwitch_2[1].6
0283	2A8C	jmp     _L6
				;83		{
				;84			if(WorkMode != ALARM_MODE)
0284	4734	mov     a, WorkMode[0]
0285	0A03	sub     a, 3H
0286	3D0A	sz      Z
0287	2A8C	jmp     _L6
				;85			{
				;86				WorkMode = ALARM_MODE;	//0288	0F03	mov     a, 3H
0289	40B4	mov     WorkMode[0], a
				;87				ErrType = ERR_TR_SHORT;
028A	0F04	mov     a, 4H
028B	40B2	mov     ErrType[0], a
				;88			}		
				;89		}
				;90		
				;91		if(ZeroFlag)
				_L6:
028C	7868	snz     _GetSwitch_2.0
028D	2A96	jmp     _L7
				;92		{
				;93			if(WorkMode != ALARM_MODE)
028E	4734	mov     a, WorkMode[0]
028F	0A03	sub     a, 3H
0290	3D0A	sz      Z
0291	2A96	jmp     _L7
				;94			{
				;95				WorkMode = ALARM_MODE;	//0292	0F03	mov     a, 3H
0293	40B4	mov     WorkMode[0], a
				;96				ErrType = ERR_NO_ZERO;
0294	0F01	mov     a, 1H
0295	40B2	mov     ErrType[0], a
				;97			}		
				;98		}
				;99	
				;100	    switch(WorkMode)
				_L7:
0296	4734	mov     a, WorkMode[0]
0297	0A00	sub     a, 0H
0298	3D0A	sz      Z
0299	2AA6	jmp     _L9
029A	0A01	sub     a, 1H
029B	3D0A	sz      Z
029C	2AB2	jmp     _L10
029D	4734	mov     a, WorkMode[0]
029E	0A02	sub     a, 2H
029F	3D0A	sz      Z
02A0	2ABE	jmp     _L11
02A1	4734	mov     a, WorkMode[0]
02A2	0A03	sub     a, 3H
02A3	390A	snz     Z
02A4	2B62	jmp     _L3
02A5	2AF2	jmp     _L48
				;101	    {
				;102		    case POWERON_MODE:
				;103	    		LED_YEL_ON;
				_L9:
02A6	3494	clr     PA1
				;104	    		LED_ORG_ON;
02A7	3540	clr     PC2
				;105	    		LED_RED_ON;
02A8	34C0	clr     PC1
				;106	    		if(Flag1S)						//02A9	7869	snz     _GetSwitch_2[1].0
02AA	2AB0	jmp     _L13
				;107	    		{
				;108		    		WorkMode = RDY_MODE;		//02AB	0F01	mov     a, 1H
02AC	40B4	mov     WorkMode[0], a
				;109		    		LED_YEL_OFF;
02AD	3094	set     PA1
				;110		    		LED_ORG_OFF;
02AE	3140	set     PC2
				;111		    		LED_RED_OFF;    		
02AF	30C0	set     PC1
				;112	    		}
				;113	    		HeaterFlag = false;
				_L13:
02B0	76BF	clr     maiFlagA[0].5
				;114		        break;
02B1	2B62	jmp     _L3
				;115		    case RDY_MODE:
				;116	    		LED_YEL_OFF;
				_L10:
02B2	3094	set     PA1
				;117	    		LED_ORG_OFF;
02B3	3140	set     PC2
				;118	    		LED_RED_OFF;    		
02B4	30C0	set     PC1
				;119		    	HeaterFlag = false;
02B5	76BF	clr     maiFlagA[0].5
				;120		    	if(G_Input_Flag[KEY_MODE] == 1)		//02B6	5735	sdza    G_Input_Flag[0]
02B7	2B62	jmp     _L3
				;121		    	{
				;122		    		G_Input_Flag[KEY_MODE] = 0;
02B8	5F35	clr     G_Input_Flag[0]
				;123		    		HeartMode = LOW_40C;			//02B9	5F33	clr     HeartMode[0]
				;124		    		WorkMode = RUN_MODE;			//02BA	0F02	mov     a, 2H
02BB	40B4	mov     WorkMode[0], a
				;125		    		Time60Min = 0;					//02BC	5F39	clr     Time60Min[0]
02BD	2B62	jmp     _L3
				;126		    	}
				;127		        break;
				;128		    case RUN_MODE:    
				;129		    	switch(HeartMode)					//				_L11:
02BE	4733	mov     a, HeartMode[0]
02BF	40E8	mov     _GetSwitch_2, a
02C0	4768	mov     a, _GetSwitch_2
02C1	0A00	sub     a, 0H
02C2	3D0A	sz      Z
02C3	2ACF	jmp     _L16
02C4	0A01	sub     a, 1H
02C5	3D0A	sz      Z
02C6	2AD2	jmp     _L17
02C7	4768	mov     a, _GetSwitch_2
02C8	0A02	sub     a, 2H
02C9	390A	snz     Z
02CA	2AD5	jmp     _L15
				;130		    	{
				;131		    		case LOW_40C:
				;132	#if EN_FLICK > 0	    		
				;133		    			if((Flag100ms)||(EnThyOutFlag))
				;134		    			{
				;135			    			LED_YEL_ON;
				;136		    			}
				;137		    			else
				;138		    			{
				;139		    				LED_YEL_OFF;
				;140		    			}
				;141	#else
				;142		    			LED_YEL_ON;
				_L16:
02CF	3494	clr     PA1
				;143	#endif	    			
				;144			    		LED_ORG_OFF;
02D0	3140	set     PC2
02D1	2AD4	jmp     _L45
				;145			    		LED_RED_OFF;
				;146		    			break;
				;147		    		case LOW_50C:
				;148			    		LED_YEL_OFF;
				_L17:
02D2	3094	set     PA1
				;149	#if EN_FLICK > 0	    				    		
				;150		    			if((Flag100ms)||(EnThyOutFlag))
				;151		    			{
				;152			    			LED_ORG_ON;
				;153		    			}
				;154		    			else
				;155		    			{
				;156		    				LED_ORG_OFF;
				;157		    			}
				;158	#else
				;159			    			LED_ORG_ON;
02D3	3540	clr     PC2
				;160	#endif	    					    				    		
				;161			    		LED_RED_OFF;
				_L45:
02D4	30C0	set     PC1
				;162		    			break;
				;163		    		case LOW_60C:
				;164			    		LED_YEL_OFF;
02CB	3094	set     PA1
				;165			    		LED_ORG_OFF;
02CC	3140	set     PC2
				;166	#if EN_FLICK > 0	    				    				    		
				;167		    			if((Flag100ms)||(EnThyOutFlag))	//				;168		    			{
				;169			    			LED_RED_ON;
				;170		    			}
				;171		    			else
				;172		    			{
				;173		    				LED_RED_OFF;
				;174		    			}
				;175	#else
				;176			    		LED_RED_ON;					
02CD	34C0	clr     PC1
				;177	#endif	    				
				;178		    			break;
02CE	2AD5	jmp     _L15
				;179		    		default:
				;180		    			break;
				;181		    	}
				;182		    	if(G_Input_Flag[KEY_MODE] == 1)			//				_L15:
02D5	5735	sdza    G_Input_Flag[0]
02D6	2AE3	jmp     _L19
				;183		    	{
				;184		    		G_Input_Flag[KEY_MODE] = 0;
02D7	5F35	clr     G_Input_Flag[0]
				;185		    		HeartMode++;
02D8	5468	inca    _GetSwitch_2
02D9	40D5	mov     ra, a
02DE	4755	mov     a, ra
02DF	40B3	mov     HeartMode[0], a
02E0	2AE2	jmp     _L21
				;186		    		if(HeartMode > LOW_60C)
02DA	0F02	mov     a, 2H
02DB	4255	sub     a, ra
02DC	380A	snz     C
02DD	2AE1	jmp     _L20
				;187		    		{
				;188		    			HeartMode = LOW_40C;
				_L20:
02E1	5F33	clr     HeartMode[0]
				;189		    		}
				;190		    		Time60Min = 0;
				_L21:
02E2	5F39	clr     Time60Min[0]
				;191		    	}
				;192		    	OutCtrl();								//				;193		    	
				;194		    	if(Time60Min >= WORK_TIME_MAX)			//				_L19:
02E3	0F3B	mov     a, 3BH
02E4	4239	sub     a, Time60Min[0]
02E5	3C0A	sz      C
02E6	2AEA	jmp     _L22
				;195		    	{
				;196		    		Time60Min = 0;
02E7	5F39	clr     Time60Min[0]
				;197		    		WorkMode = RDY_MODE;				//02E8	0F01	mov     a, 1H
02E9	40B4	mov     WorkMode[0], a
				;198		    	}
				;199		    	if(G_Input_Flag[KEY_MODE] == LONG_KEY)	//				_L22:
02EA	4735	mov     a, G_Input_Flag[0]
02EB	0A0A	sub     a, AH
02EC	390A	snz     Z
02ED	2B62	jmp     _L3
				;200		    	{
				;201		    		G_Input_Flag[KEY_MODE] = 0;
02EE	5F35	clr     G_Input_Flag[0]
				;202		    		WorkMode = RDY_MODE;				//02EF	0F01	mov     a, 1H
02F0	40B4	mov     WorkMode[0], a
02F1	2B62	jmp     _L3
				;203		    	}
				;204		    	
				;205		        break;
				;206			case ALARM_MODE:
				;207				IO_HEATTR = false;						//				_L48:
02F2	3714	clr     PA6
				;208				if(Flag500ms)
02F3	79E8	snz     _GetSwitch_2.3
02F4	2B62	jmp     _L3
				;209				{
				;210					Flag500ms = false;					//02F5	75BF	clr     maiFlagA[0].3
				;211					if(ErrType == ERR_SHORT)
02F6	4732	mov     a, ErrType[0]
02F7	40E8	mov     _GetSwitch_2, a
02F8	4768	mov     a, _GetSwitch_2
02F9	0A02	sub     a, 2H
02FA	390A	snz     Z
02FB	2B07	jmp     _L24
				;212					{
				;213						LED_RED_REVERSE;
02FC	1940	rra     PC
02FD	0E7F	and     a, 7FH
02FE	40D5	mov     ra, a
02FF	0F01	mov     a, 1H
0300	44D5	xorm    a, ra
0301	0F01	mov     a, 1H
0302	46D5	andm    a, ra
0303	4755	mov     a, ra
0304	43D5	addm    a, ra
0305	34C0	clr     PC1
0306	2B17	jmp     _L46
				;214					}
				;215					if(ErrType == ERR_NO_LOAD)
				_L24:
0307	4768	mov     a, _GetSwitch_2
0308	0A03	sub     a, 3H
0309	390A	snz     Z
030A	2B1A	jmp     _L25
				;216					{
				;217						LED_ORG_REVERSE;
030B	1940	rra     PC
030C	1985	rr      ACC
030D	0E3F	and     a, 3FH
030E	40D6	mov     rb, a
030F	0F01	mov     a, 1H
0310	44D6	xorm    a, rb
0311	0F01	mov     a, 1H
0312	46D6	andm    a, rb
0313	5F55	clr     ra
0314	50D6	sz      rb
0315	7155	set     ra.2
0316	3540	clr     PC2
				_L46:
0317	4755	mov     a, ra
0318	05C0	orm     a, PC
0319	2B62	jmp     _L3
				;218					}
				;219					if(ErrType == ERR_TR_SHORT)
				_L25:
031A	4768	mov     a, _GetSwitch_2
031B	0A04	sub     a, 4H
031C	390A	snz     Z
031D	2B3A	jmp     _L26
				;220					{
				;221						LED_RED_REVERSE;
031E	1940	rra     PC
031F	0E7F	and     a, 7FH
0320	40D5	mov     ra, a
0321	0F01	mov     a, 1H
0322	44D5	xorm    a, ra
0323	0F01	mov     a, 1H
0324	46D5	andm    a, ra
0325	4755	mov     a, ra
0326	43D5	addm    a, ra
0327	34C0	clr     PC1
0328	4755	mov     a, ra
0329	05C0	orm     a, PC
				;222						LED_ORG_REVERSE;
032A	1940	rra     PC
032B	1985	rr      ACC
032C	0E3F	and     a, 3FH
032D	40D6	mov     rb, a
032E	0F01	mov     a, 1H
032F	44D6	xorm    a, rb
0330	0F01	mov     a, 1H
0331	46D6	andm    a, rb
0332	5F55	clr     ra
0333	50D6	sz      rb
0334	7155	set     ra.2
0335	3540	clr     PC2
0336	4755	mov     a, ra
0337	05C0	orm     a, PC
				;223						FUSE_OPEN;	//0338	3394	set     PA7
0339	2B62	jmp     _L3
				;224					}
				;225					if(ErrType == ERR_NO_ZERO)
				_L26:
033A	5768	sdza    _GetSwitch_2
033B	2B62	jmp     _L3
				;226					{
				;227						LED_RED_REVERSE;
033C	1940	rra     PC
033D	0E7F	and     a, 7FH
033E	40D5	mov     ra, a
033F	0F01	mov     a, 1H
0340	44D5	xorm    a, ra
0341	0F01	mov     a, 1H
0342	46D5	andm    a, ra
0343	4755	mov     a, ra
0344	43D5	addm    a, ra
0345	34C0	clr     PC1
0346	4755	mov     a, ra
0347	05C0	orm     a, PC
				;228						LED_ORG_REVERSE;
0348	1940	rra     PC
0349	1985	rr      ACC
034A	0E3F	and     a, 3FH
034B	40D6	mov     rb, a
034C	0F01	mov     a, 1H
034D	44D6	xorm    a, rb
034E	0F01	mov     a, 1H
034F	46D6	andm    a, rb
0350	5F55	clr     ra
0351	50D6	sz      rb
0352	7155	set     ra.2
0353	3540	clr     PC2
0354	4755	mov     a, ra
0355	05C0	orm     a, PC
				;229						LED_YEL_REVERSE;					
0356	1914	rra     PA
0357	0E7F	and     a, 7FH
0358	40D5	mov     ra, a
0359	0F01	mov     a, 1H
035A	44D5	xorm    a, ra
035B	0F01	mov     a, 1H
035C	46D5	andm    a, ra
035D	4755	mov     a, ra
035E	43D5	addm    a, ra
035F	3494	clr     PA1
0360	4755	mov     a, ra
0361	0594	orm     a, PA
				_L3:
0362	0003	ret
				;230					}
				;231				}
				;232		}
				;233	}
				;234	
				;file E:\				;1	#include "base.h"
				;2	#define EXTERN extern
				;3	#include "Var.h"
				;4	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				;5	void InitSys(void)
				;6	{
				;7	//	unsigned char i;
				;8	// System clock setting
				;9		_smod = 0b11100001;					// fsys=fH=8MHz; IDLE mode Disable
				_InitSys:
				_InitSys:
0363	0FE1	mov     a, E1H
0364	008B	mov     SMOD, a
				;10			// Watchdog Timer Setting  
				;11		_wdtc = 0b01010101;					// set WDT Timeout period= 2^16/fsub=2^16/32.768kHz=2sec; Enable WDT
0365	0F55	mov     a, 55H
0366	009A	mov     WDTC, a
				;12	
				;13	    _lvrc = 0b00110011; //2.55V
0367	0F33	mov     a, 33H
0368	009D	mov     LVRC, a
				;14	    _cpc = 0x08;
0369	0F08	mov     a, 8H
036A	00BE	mov     CPC, a
				;15	//io
				;16	    _pa = 0x00;
036B	1F14	clr     PA
				;17	    _pac = 0x19;
036C	0F19	mov     a, 19H
036D	0095	mov     PAC, a
				;18	    _papu = 0x7E; 
036E	0F7E	mov     a, 7EH
036F	0096	mov     PAPU, a
				;19	    FUSE_CLOSE;
0370	3794	clr     PA7
				;20	    _pb = 0x10;
0371	0F10	mov     a, 10H
0372	00A5	mov     PB, a
				;21	    _pbc  = 0b00000111;
0373	0F07	mov     a, 7H
0374	00A6	mov     PBC, a
				;22	    _pbpu = 0b11111000;	//0375	0FF8	mov     a, F8H
0376	00A7	mov     PBPU, a
				;23	
				;24	    _pc    = 0x07;
0377	0F07	mov     a, 7H
0378	00C0	mov     PC, a
				;25	    _pcc   = 0x01;
0379	0F01	mov     a, 1H
037A	00C1	mov     PCC, a
				;26	    _pcpu  = 0x07;
037B	0F07	mov     a, 7H
037C	00C2	mov     PCPU, a
				;27		IO_HEATTR = false;						//037D	3714	clr     PA6
				;28	  
				;29	//adc init
				;30	    _acerl = 0b00001010;
037E	0F0A	mov     a, AH
037F	00A4	mov     ACERL, a
				;31	    _adcr0 = ADC_PTC1;
0380	0F11	mov     a, 11H
0381	00A2	mov     ADCR0, a
				;32	    _adcr1 = 0x06;
0382	0F06	mov     a, 6H
0383	00A3	mov     ADCR1, a
				;33	    STAR_ADC();
0384	37A2	clr     START
0385	33A2	set     START
0386	37A2	clr     START
				;34	//time2 init
				;35	    _t2cp = 1;
0387	3119	set     T2CP
				;36	    _tm2c0 = 0b00110000;
0388	0F30	mov     a, 30H
0389	00A8	mov     TM2C0, a
				;37	    _tm2c1 = 0b10101000;
038A	0FA8	mov     a, A8H
038B	00A9	mov     TM2C1, a
				;38	    _tm2al = 0;
038C	1F2C	clr     TM2AL
				;39	    _tm2ah = 0;
038D	1F2D	clr     TM2AH
				;40	    _tm2rp = 0b00100000;   //0~8192 682us tp2 pwm
038E	0F20	mov     a, 20H
038F	00AE	mov     TM2RP, a
				;41	    _t2on=1;
0390	31A8	set     T2ON
				;42	    _mf1e=1;
0391	300F	set     MF1E
				;43	    _t2pe=1;
0392	3112	set     T2PE
				;44	//time1 init
				;45	    _t1cp = 0;
0393	3499	clr     T1CP
				;46	    _tm1c0 = 0b00010000;
0394	0F10	mov     a, 10H
0395	00B6	mov     TM1C0, a
				;47	    _tm1c1 = 0b10101000;
0396	0FA8	mov     a, A8H
0397	00B7	mov     TM1C1, a
				;48	    _tm1al = 0;
0398	1F3A	clr     TM1AL
				;49	    _tm1ah = 0;
0399	1F3B	clr     TM1AH
				;50	    _tm1rpl = 0xff;
039A	1FBC	set     TM1RPL
				;51	    _tm1rph = 0x03;
039B	0F03	mov     a, 3H
039C	00BD	mov     TM1RPH, a
				;52	    _t1on=1;
039D	31B6	set     T1ON
				;53	    //_mf1e=0;
				;54	    //_t1pe=1;
				;55	#ifdef DEBUG_SWITCH
				;56	//time0 init 208us  4800
				;57	    _tm0al=0xc0;
039E	0FC0	mov     a, C0H
039F	00B3	mov     TM0AL, a
				;58	    _tm0ah=0x09;
03A0	0F09	mov     a, 9H
03A1	00B4	mov     TM0AH, a
				;59	#else
				;60	//time0  500us
				;61	    _tm0al=0x70;
				;62	    _tm0ah=0x17;
				;63	#endif
				;64		// ***Timer0 Setting***
				;65		_tm0c0=0b00110000;                  // TM0 counter clock=fH/64=8MHz/64=125kHz; TM0 counter Off
03A2	0F30	mov     a, 30H
03A3	00AF	mov     TM0C0, a
				;66		_tm0c1=0b11000001;                  // TM0 in timer mode; 
03A4	0FC1	mov     a, C1H
03A5	00B0	mov     TM0C1, a
				;67		
				;68		_tm0al=0xfa;		                // set TM0 CCRA=250; Timer interval = 250/125kHz=2ms
03A6	0FFA	mov     a, FAH
03A7	00B3	mov     TM0AL, a
				;69		_tm0ah=0x00; 	                    
03A8	1F34	clr     TM0AH
				;70		_mf0e=1;							// Enable multi-function 0 for Timer0 interrupt
03A9	318E	set     MF0E
				;71	//int
				;72	// Ext Int 1 Setting
				;73		_int0s0 = 1;_int0s1 = 0;				// Set rising edge interrupt for INT1
03AA	300D	set     INT0S0
03AB	348D	clr     INT0S1
				;74	    //_integ=0x03;
				;75	    _int0e = true;  
03AC	308E	set     INT0E
				;76		// ***Time Base0&1 Setting***
				;77		_tbc=0b11110101;					// enable Time Base, fTB=fsys/4=2MHz, select TB0 Time-out period=8192/fTB=4.096ms; 
03AD	0FF5	mov     a, F5H
03AE	009B	mov     TBC, a
				;78											// select TB1 Time-out period=32768/fTB=1sec; 
				;79		_tb0e=1;							// enable Time Base0 interrupt control   
03AF	318F	set     TB0E
				;80	    _emi = 1;    
03B0	300E	set     EMI
03B1	0003	ret
				;81	}
				;82	
				;83	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				;84	void InitRam(void)
				;85	{
				;86	    adcsp=0;
				_InitRam:
				_InitRam:
03B2	5F38	clr     adcsp[0]
				;87	    adcsele=0;
03B3	5F37	clr     adcsele[0]
				;88	
				;89	    WorkMode = POWERON_MODE;	
03B4	5F34	clr     WorkMode[0]
				;90	    HeartMode = LOW_40C; 				//03B5	5F33	clr     HeartMode[0]
				;91		G_Input_Flag[KEY_MODE] = 0;
03B6	5F35	clr     G_Input_Flag[0]
				;92		Flag500ms = false;
03B7	75BF	clr     maiFlagA[0].3
				;93		Flag1S = false;
03B8	743E	clr     maiFlagB[0].0
				;94		Time60Min = 0;
03B9	5F39	clr     Time60Min[0]
				;95		FlagStartDetect = false;
03BA	77BF	clr     maiFlagA[0].7
				;96		TaskKeyRdy = false;
03BB	76BD	clr     LEDG[0].5
				;97		HeaterFlag = false;
03BC	76BF	clr     maiFlagA[0].5
				;98		Time1MinCnt = 0;
03BD	5F36	clr     Time1MinCnt[0]
				;99		EnThyOutFlag = false;
03BE	763F	clr     maiFlagA[0].4
				;100		TRShortFlag = false;
03BF	773E	clr     maiFlagB[0].6
				;101		ShortFlag = false;
03C0	74BF	clr     maiFlagA[0].1
				;102		NoLoadFlag = false;
03C1	753F	clr     maiFlagA[0].2
				;103		ZeroFlag = false;
03C2	743F	clr     maiFlagA[0].0
				;104		
				;105		ShortCnt1 = 0;
03C3	5F22	clr     ShortCnt1[0]
				;106		ShortCnt2 = 0;
03C4	5F21	clr     ShortCnt2[0]
				;107		AdcCnt = 0;
03C5	5F20	clr     AdcCnt[0]
				;108		NoZeroTime = 0;
03C6	5F26	clr     NoZeroTime[0]
03C7	0003	ret
				;109	}
				;file E:\				;1	#include "base.h"
				;2	#define EXTERN extern
				;3	#include "Var.h"
				;4	
				;5	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				;6	volatile static unsigned char old_in_status[4]  __attribute__ ((at(0x1ee)));
				;7	volatile static unsigned char in_count[4]  __attribute__ ((at(0x1f2)));
				;8	
				;9	
				;10	void GetKey(void)
				;11	{
				;12	    u8 i;
				;13	    u8 new_status;
				;14		static u8 LongTimeCnt __attribute__ ((at(0x1e9)));
				;15	
				;16	    for(i = 0; i < CONFIG_IN_NUM; i++)
				;17	    {
				;18	    	if(i == 0)
				;19	        	new_status = KEY;
				_GetKey:
				_GetKey:
0460	5F55	clr     ra
0461	3D94	sz      PA3
0462	54D5	inc     ra
				;20	
				;21	        if(old_in_status[i] != new_status)
0463	0FEE	mov     a, EEH
0464	0083	mov     MP1, a
0465	0F01	mov     a, 1H
0466	0081	mov     MP0, a
0467	0701	mov     a, MP0
0468	0084	mov     BP, a
0469	0702	mov     a, [02H]
046A	40D6	mov     rb, a
046F	4756	mov     a, rb
0470	4255	sub     a, ra
0471	3D0A	sz      Z
0472	2C7E	jmp     _L2
				;22	            in_count[i] ++;
046B	0FF2	mov     a, F2H
046C	0083	mov     MP1, a
046D	0F01	mov     a, 1H
046E	0081	mov     MP0, a
0473	0701	mov     a, MP0
0474	0084	mov     BP, a
0475	0702	mov     a, [02H]
0476	40E8	mov     _GetSwitch_2, a
0477	5468	inca    _GetSwitch_2
0478	40D6	mov     rb, a
0479	0701	mov     a, MP0
047A	0084	mov     BP, a
047B	4756	mov     a, rb
047C	0082	mov     [02H], a
047D	2C82	jmp     _L3
				;23	        else
				;24	            in_count[i] = 0;
				_L2:
047E	0701	mov     a, MP0
047F	0084	mov     BP, a
0480	0F00	mov     a, 0H
0481	0082	mov     [02H], a
				;25	
				;26	        if(in_count[i] > 20)
				_L3:
0482	0FF2	mov     a, F2H
0483	0083	mov     MP1, a
0484	0F01	mov     a, 1H
0485	0081	mov     MP0, a
0486	0701	mov     a, MP0
0487	0084	mov     BP, a
0488	0702	mov     a, [02H]
0489	40D6	mov     rb, a
048A	0F14	mov     a, 14H
048B	4256	sub     a, rb
048C	3C0A	sz      C
048D	2C9D	jmp     _L4
				;27	        {
				;28	            if(new_status == 0)
048E	50D5	sz      ra
048F	2C93	jmp     _L5
				;29	            {
				;30	                G_Input_Flag[i] = 1;
0490	0F01	mov     a, 1H
0491	40B5	mov     G_Input_Flag[0], a
0492	2C95	jmp     _L6
				;31	            }
				;32	            else
				;33	            {
				;34	                G_Input_Flag[i] = 2;
				_L5:
0493	0F02	mov     a, 2H
0494	40B5	mov     G_Input_Flag[0], a
				;35	            }
				;36	        	old_in_status[i] = new_status;
				_L6:
0495	0FEE	mov     a, EEH
0496	0083	mov     MP1, a
0497	0F01	mov     a, 1H
0498	0081	mov     MP0, a
0499	0701	mov     a, MP0
049A	0084	mov     BP, a
049B	4755	mov     a, ra
049C	0082	mov     [02H], a
				;37	        }        
				;38	    }
				;39	    if(old_in_status[KEY_MODE] == 0)
				_L4:
049D	0FEE	mov     a, EEH
049E	0083	mov     MP1, a
049F	0F01	mov     a, 1H
04A0	0081	mov     MP0, a
04A1	0701	mov     a, MP0
04A2	0084	mov     BP, a
04A3	0702	mov     a, [02H]
04A4	40D5	mov     ra, a
04A9	50D5	sz      ra
04AA	2CBC	jmp     _L7
				;40	    {
				;41	    	LongTimeCnt++;
04A5	0FE9	mov     a, E9H
04A6	0083	mov     MP1, a
04A7	0F01	mov     a, 1H
04A8	0081	mov     MP0, a
04AB	0701	mov     a, MP0
04AC	0084	mov     BP, a
04AD	0702	mov     a, [02H]
04AE	40E8	mov     _GetSwitch_2, a
04AF	5468	inca    _GetSwitch_2
04B0	40D5	mov     ra, a
04B1	0701	mov     a, MP0
04B2	0084	mov     BP, a
04B3	4755	mov     a, ra
04B4	0082	mov     [02H], a
				;42	    	if(LongTimeCnt >= 250)
04B5	0FF9	mov     a, F9H
04B6	4255	sub     a, ra
04B7	3C0A	sz      C
04B8	2CC0	jmp     _L1
				;43	    	{
				;44	    		G_Input_Flag[KEY_MODE] = LONG_KEY;
04B9	0F0A	mov     a, AH
04BA	40B5	mov     G_Input_Flag[0], a
04BB	2CC0	jmp     _L1
				;45	    	}
				;46	    }
				;47	    else
				;48	    {
				;49	    	LongTimeCnt = 0;
				_L7:
04BC	0701	mov     a, MP0
04BD	0084	mov     BP, a
04BE	0F00	mov     a, 0H
04BF	0082	mov     [02H], a
				_L1:
04C0	0003	ret
				;50	    }
				;51	}
				;52	
				;53	
				;54	void GetSwitch(void)
				;55	{
				;56		static unsigned char swCntA = 0;
				;57		if(FlagStartDetect)	//				_GetSwitch:
				_GetSwitch:
04C1	7BBF	snz     maiFlagA[0].7
04C2	2CD7	jmp     _L10
04C3	4754	mov     a, swCntA[0]
04C4	40E8	mov     _GetSwitch_2, a
				;58		{
				;59		    if(PROTECT)
04C5	3925	snz     PB2
04C6	2CD0	jmp     _L12
				;60		    {
				;61		        if(swCntA < 200) 
04C7	0FC7	mov     a, C7H
04C8	4268	sub     a, _GetSwitch_2
04C9	380A	snz     C
04CA	2CCE	jmp     _L13
				;62		        	swCntA++;
04CB	5468	inca    _GetSwitch_2
04CC	40D4	mov     swCntA[0], a
04CD	2CD7	jmp     _L10
				;63		        else 
				;64		        	ShortFlag = true;
				_L13:
04CE	70BF	set     maiFlagA[0].1
04CF	2CD7	jmp     _L10
				;65		    }
				;66		    else
				;67		    {
				;68		        if(swCntA>0) 
				_L12:
04D0	50E8	sz      _GetSwitch_2
04D1	2CD3	jmp     _LI1
04D2	2CD6	jmp     _L14
				;69		        	swCntA--;
				_LI1:
04D3	5568	deca    _GetSwitch_2
04D4	40D4	mov     swCntA[0], a
04D5	2CD7	jmp     _L10
				;70		        else 
				;71		        	ShortFlag = false;
				_L14:
04D6	74BF	clr     maiFlagA[0].1
				_L10:
04D7	0003	ret
				L04D8:
04D8	1483	inc     MP1
				L04D9:
04D9	3F81	sz      MP0.7
04DA	2CDF	jmp     L04DF
04DB	0701	mov     a, MP0
04DC	0084	mov     BP, a
04DD	0702	mov     a, [02H]
04DE	0003	ret
				L04DF:
04DF	1B01	rrca    MP0
04E0	0E3F	and     a, 3FH
04E1	0089	mov     TBHP, a
04E2	1B03	rrca    MP1
04E3	0087	mov     TBLP, a
04E4	1D05	tabrd   ACC
04E5	3C0A	sz      C
04E6	0708	mov     a, TBLH
04E7	0003	ret
				;72		    }
				;73		}
				;74	}
				data .SECTION 'DATA'
				__smod DB DUP (?) ; __smod
				__integ DB DUP (?) ; __integ
				__intc0 DB DUP (?) ; __intc0
				__intc1 DB DUP (?) ; __intc1
				__mfi0 DB DUP (?) ; __mfi0
				__mfi1 DB DUP (?) ; __mfi1
				__pa DB DUP (?) ; __pa
				__pac DB DUP (?) ; __pac
				__papu DB DUP (?) ; __papu
				__tmpc DB DUP (?) ; __tmpc
				__wdtc DB DUP (?) ; __wdtc
				__tbc DB DUP (?) ; __tbc
				__lvrc DB DUP (?) ; __lvrc
				__adrl DB DUP (?) ; __adrl
				__adrh DB DUP (?) ; __adrh
				__adcr0 DB DUP (?) ; __adcr0
				__adcr1 DB DUP (?) ; __adcr1
				__acerl DB DUP (?) ; __acerl
				__pb DB DUP (?) ; __pb
				__pbc DB DUP (?) ; __pbc
				__pbpu DB DUP (?) ; __pbpu
				__tm2c0 DB DUP (?) ; __tm2c0
				__tm2c1 DB DUP (?) ; __tm2c1
				__tm2al DB DUP (?) ; __tm2al
				__tm2ah DB DUP (?) ; __tm2ah
				__tm2rp DB DUP (?) ; __tm2rp
				__tm0c0 DB DUP (?) ; __tm0c0
				__tm0c1 DB DUP (?) ; __tm0c1
				__tm0al DB DUP (?) ; __tm0al
				__tm0ah DB DUP (?) ; __tm0ah
				__tm1c0 DB DUP (?) ; __tm1c0
				__tm1c1 DB DUP (?) ; __tm1c1
				__tm1al DB DUP (?) ; __tm1al
				__tm1ah DB DUP (?) ; __tm1ah
				__tm1rpl DB DUP (?) ; __tm1rpl
				__tm1rph DB DUP (?) ; __tm1rph
				__cpc DB DUP (?) ; __cpc
				__pc DB DUP (?) ; __pc
				__pcc DB DUP (?) ; __pcc
				__pcpu DB DUP (?) ; __pcpu
				AdcCnt DB DUP (?) ; AdcCnt
				ShortCnt2 DB DUP (?) ; ShortCnt2
				ShortCnt1 DB DUP (?) ; ShortCnt1
				txBit DB DUP (?) ; txBit
				txSp DB DUP (?) ; txSp
				txBuf DB DUP (?) ; txBuf
				NoZeroTime DB DUP (?) ; NoZeroTime
				ModeScnt DB DUP (?) ; ModeScnt
				adjStep DB DUP (?) ; adjStep
				runErroCnt DB DUP (?) ; runErroCnt
				ntcErroH DB DUP (?) ; ntcErroH
				ntcErroL DB DUP (?) ; ntcErroL
				delayWate DB DUP (?) ; delayWate
				clrTime DB 2 DUP (?) ; clrTime
				hotTmp DB DUP (?) ; hotTmp
				hotDelay DB DUP (?) ; hotDelay
				adjDiv DB DUP (?) ; adjDiv
				ErrType DB DUP (?) ; ErrType
				HeartMode DB DUP (?) ; HeartMode
				WorkMode DB DUP (?) ; WorkMode
				G_Input_Flag DB DUP (?) ; G_Input_Flag
				Time1MinCnt DB DUP (?) ; Time1MinCnt
				adcsele DB DUP (?) ; adcsele
				adcsp DB DUP (?) ; adcsp
				Time60Min DB DUP (?) ; Time60Min
				sysTime DB 2 DUP (?) ; sysTime
				LEDH DB DUP (?) ; LEDH
				LEDG DB DUP (?) ; LEDG
				maiFlagB DB DUP (?) ; maiFlagB
				maiFlagA DB DUP (?) ; maiFlagA
				TempArray DB DUP (?) ; TempArray
				k DB 2 DUP (?) ; k
				IOZeroStaBak DB DUP (?) ; IOZeroStaBak
				IOZeroSta DB DUP (?) ; IOZeroSta
				Time100Cnt DB DUP (?) ; Time100Cnt
				Time1SCnt DB DUP (?) ; Time1SCnt
				Time500Cnt DB DUP (?) ; Time500Cnt
				TaskADCCnt DB DUP (?) ; TaskADCCnt
				swCntA DB DUP (?) ; swCntA
				ra DB DUP (?)
				rb DB DUP (?)
				rc DB DUP (?)
				rd DB DUP (?)
				re DB DUP (?)
				rf DB DUP (?)
				rg DB DUP (?)
				rh DB DUP (?)
				r110 DB DUP (?)
				r210 DB DUP (?)
				r10c DB DUP (?)
				r20c DB DUP (?)
				r11c DB DUP (?)
				r21c DB DUP (?)
				ra1c DB DUP (?)
				rb1c DB DUP (?)
				r104 DB DUP (?)
				r204 DB DUP (?)
				_ISRTime0Base_2 DB DUP (?)
				_GetSwitch_2 DB DUP (?)
				adcBuf DB DUP (?) ; adcBuf
				adc1Buf DB DUP (?) ; adc1Buf
				LongTimeCnt DB DUP (?) ; LongTimeCnt
				old_in_status DB DUP (?) ; old_in_status
				in_count DB DUP (?) ; in_count
